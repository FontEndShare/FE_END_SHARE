### 栈空间

> 由系统自行管理

### 堆内存：

代际假说：

-   1.大部分对象在内存中存活时间很短
-   2.不死的对象会活的更久,比如全局 window，dom，全局 api 等对象

判断活动对象：

> 将一个称为 GC Roots 的对象（在浏览器环境中，GC Roots 可以包括：全局的 window 对象、所有原生 dom 节点集合等等）作为所有初始存活的对象集合，从这个对象出发，进行遍历，遍历到的就认为是可访问的，为活动对象，需要保留；如果没有遍历到的对象，就是不可访问的，这些就是非活动对象，可能就会被垃圾回收。

划分：

> 1.新生代：新分配的对象会放入新生代中

    -   1.1 from space
    -   1.2 to space

> 2.老生代：通过 v8 的晋升机制将新生代中的对象在满足一定条件下放入老生代中

Scavenger 算法：主要用于管理新生代堆内存

> 新分配的对象放入新生代的 from space 内存中
> 当 from space 内存空间达到上限时，会对 from space 内存进行整理，将活动对象拷贝至 to space 空间内，然后清除 from space 空间内的非活动对象
> 将 from space 和 to space 进行角色互换

Mark-Sweep & Mark-Compact 算法：主要用于老生代的内存管理

> 标记-清除过程：与之前讲过的可访问性分析一致，从 GC Root 开始遍历，标记完成后，就直接进行垃圾数据的清理工作。
> 标记-整理过程：清除算法后会产生大量不连续的内存碎片，碎片过多会导致后面大对象无法分配到足够的空间，所以需要进行整理，第一步的标记是一样的，但标记完成活跃对象后，并不是进行清理，而是将所有存活的对象向一端移动，然后清理掉这端之外的内存。

优化：

> 原因：由于 js 是单线程，定期进行 gc 会导致主线程卡顿
> 手段：

    1.并行回收
    2.增量回收
    3.三色标记法
    3.写屏障
